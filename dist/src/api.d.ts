export interface Links<T> {
    /**
     * References to the current resultset
     */
    self?(): Promise<ApiResult<T>>;
    /**
     * References to the first portion of results
     */
    first?(): Promise<ApiResult<T>>;
    /**
     * References to the next portion of results
     */
    next?(): Promise<ApiResult<T>>;
    /**
     * References to the last portion of results
     */
    last?(): Promise<ApiResult<T>>;
}
export interface Meta {
    /**
     * the amount of datasets returned in this page of the response
     */
    count: number;
    /**
     * The total amount of datasets available without pagination
     */
    total: number;
    /**
     * The active limit of datasets per page
     */
    limit: number;
    /**
     * The current offset of total available datasets
     */
    offset: number;
    /**
     * The current page
     */
    page: number;
}
export declare type GenericApiResult = any;
export declare type VoidApiResult = void;
export interface ApiResult<T> {
    /**
     * Inidicates if the request itself was successfully sent to the API (no indication if the API operation was successful!)
     */
    success: boolean;
    /**
     * The result of the API operation
     */
    result: T;
    /**
     * The raw HTTP Response
     */
    response?: Response;
    /**
     * The Request options
     */
    requestInit?: RequestInit;
    /**
     * Links to other resultsets of the pagination
     */
    links?: Links<T>;
    /**
     * Pagination meta data
     */
    meta?: Meta;
    /**
     * If this is a function, it can be used to watch the process of asynchronous requests. The returned Promise is resolved when the request finished
     */
    watch?: () => Promise<ApiResult<RequestPollResult>> | null;
    /**
     * A unique request id (generated by this client)
     */
    id?: string | null;
    /**
     * indicates if the 'request' has failed or 'json' parsing failed
     */
    failureType?: string | null;
}
export interface ApiSettings {
    /**
     * The endpoint URL
     */
    endpoint?: string;
    /**
     * A map of specific URL overrides that should go to a different endpoint (e.g. a sandbox to test new API)
     * format "path:endpoint", path can be regex (string start and end with '/')
     * @example
     * { '/myNewObject\/(.*)/': 'https://myNewApi.getsandbox.com/myNewObject' }
     */
    endpointOverrides?: {
        [key: string]: string;
    };
    /**
     * The API token
     */
    token?: string;
    /**
     * The User UUID
     */
    userId?: string;
    /**
     * Default pagination limit
     */
    limit?: number;
    /**
     * Default Watchdelay in ms
     */
    watchdelay?: number;
    /**
     * Api Client identifier (used for X-Api-Client header)
     */
    apiClient?: string;
    /**
     * A custom fetch method
     */
    fetch?: Function;
}
export interface RequestOptions {
    /**
     * Page to get the resultset for
     */
    page?: number;
    /**
     * Maximum number of datasets to return per page
     */
    limit?: number;
    /**
     * Array of fields to return in the response (to reduce the size of the resultset)
     */
    fields?: string[];
    /**
     * Filters the results by a field
     * @example
     * "name=foo"
     */
    filter?: string[];
    /**
     * Field to sort the result after
     */
    sort?: string | string[];
}
export interface RequestPollResult {
    /**
     * Current status of the watched request
     */
    message: string;
    /**
     * Short status
     */
    status: string;
    /**
     * Time when the request was created
     */
    create_time: string;
}
export interface BaseRelationObject {
    object_name?: string;
    object_uuid?: string;
}
/**
 * interface with basic properties each object (server, storage ...) should have
 */
export interface BaseObject {
    object_uuid?: string;
    status?: string;
    name?: string;
    labels?: string[];
    location_uuid?: string;
    relations?: {
        [key: string]: BaseRelationObject[];
    };
}
export interface LogData {
    result: ApiResult<unknown>;
    response: Response;
    /**
     * Unique request id (generated by client)
     */
    id: string;
    requestInit: RequestInit;
}
export declare class GSError extends Error {
    result: GenericApiResult;
    success: boolean;
    response: Response;
    constructor(message: any, result: any);
}
export declare class APIClass {
    private settings;
    /**
     * Store api client in current session
     * @param _client  String
     */
    storeClient(_client: string): void;
    /**
     * Store Token for Current Session
     * @param _token Secret Token
     */
    storeToken(_token: string, _userId: string): void;
    /**
     * Update local Request Options
     *
     * @param _option
     */
    setOptions: (_option: ApiSettings) => void;
    /**
     * Start the API Request
     *
     * @param _path
     * @param _options
     * @param _callback
     * @returns {Promise}
     */
    request(_path: string, _options: RequestInit, _callback?: (response: Response, result: ApiResult<GenericApiResult>) => void): Promise<ApiResult<GenericApiResult>>;
    /**
     * Build Option URL to expand URL
     * @param _options
     * @returns {string}
     */
    private buildRequestURL;
    /**
     * Start Get Call
     * @param _path
     * @param _callback
     */
    get(_path: string, _options?: RequestOptions | Function, _callback?: (response: Response, result: ApiResult<GenericApiResult>) => void): Promise<ApiResult<GenericApiResult>>;
    /**
     * Start Delete Call
     * @param _path
     * @param _callback
     */
    remove(_path: string, _callback?: (response: Response, result: ApiResult<GenericApiResult>) => void): Promise<ApiResult<GenericApiResult>>;
    /**
     * Send Post Request
     *
     * @param _path Endpoint
     * @param _attributes  Attributes for Post Body
     * @param _callback Optional Callback
     * @returns {Promise}
     */
    post(_path: string, _attributes: Object, _callback?: (response: Response, result: ApiResult<GenericApiResult>) => void): Promise<ApiResult<GenericApiResult>>;
    /**
     * Send PAtCH Request
     *
     * @param _path Endpoint
     * @param _attributes  Attributes for Post Body
     * @param _callback Optional Callback
     * @returns {Promise}
     */
    patch(_path: string, _attributes: Object, _callback?: (response: Response, result: ApiResult<GenericApiResult>) => void): Promise<ApiResult<GenericApiResult>>;
    /**
     * Generate URL for Linked Request. No Options are required because its in the URL already
     *
     * @param _link
     * @param _callback
     * @returns {Function}
     */
    private link;
    /**
     * Start Pooling on Request Endpoint
     *
     *
     * @param _requestid
     * @param _callback
     * @returns {Promise}
     */
    requestpooling(_requestid: string, _callback?: (response: Response, result: ApiResult<GenericApiResult>) => void): Promise<ApiResult<{
        [uuid: string]: RequestPollResult;
    }>>;
    /**
     * Recursive creating of Request Proises
     *
     *
     * @param _requestid
     * @param _resolve
     * @param _reject
     */
    buildAndStartRequestCallback(_requestid: string, _resolve: Function, _reject: Function): void;
    /**
     * Watch a Single Request until it is ready or failed
     *
     * @param _requestid
     * @param _callback
     */
    watchRequest(_requestid: string): Promise<ApiResult<RequestPollResult>>;
    private callbacks;
    /**
     * Adds a new logger for error logging
     * @param _callback
     */
    addLogger: (_callback: (logData: LogData) => void) => void;
    private log;
}
export declare const api: APIClass;
